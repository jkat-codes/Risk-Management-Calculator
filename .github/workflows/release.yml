name: 'publish'

on:
  push:
    tags:
      - 'v*'

permissions:
  contents: write

jobs:
  publish-tauri:
    permissions:
      contents: write
    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: 'macos-latest'
            args: '--target aarch64-apple-darwin'
          - platform: 'macos-latest'  
            args: '--target x86_64-apple-darwin'
          - platform: 'ubuntu-22.04'
            args: ''
          - platform: 'windows-latest'
            args: ''

    runs-on: ${{ matrix.platform }}
    steps:
      - uses: actions/checkout@v4

      - name: setup node
        uses: actions/setup-node@v4
        with:
          node-version: lts/*
          cache: 'npm'

      - name: install Rust stable
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.platform == 'macos-latest' && 'aarch64-apple-darwin,x86_64-apple-darwin' || '' }}

      - name: Rust cache
        uses: swatinem/rust-cache@v2
        with:
          workspaces: './src-tauri -> target'

      - name: install Tauri CLI
        run: cargo install tauri-cli

      - name: install dependencies (ubuntu only)
        if: matrix.platform == 'ubuntu-22.04'
        run: |
          sudo apt-get update
          sudo apt-get install -y libwebkit2gtk-4.1-dev libgtk-3-dev libayatana-appindicator3-dev librsvg2-dev

      - name: install frontend dependencies
        run: npm install

      - name: Update tauri config with token
        shell: bash
        run: |
          cat > replace_token.py << 'EOF'
          import json
          import os

          # Read the config file
          with open('src-tauri/tauri.conf.json', 'r') as f:
              config = f.read()

          print("Before replacement:")
          print("GITHUB_TOKEN_PLACEHOLDER found:", "GITHUB_TOKEN_PLACEHOLDER" in config)
          
          # Replace the placeholder with the actual token
          token = os.environ.get('PRIVATE_REPO_TOKEN', '')
          if token:
              config = config.replace('GITHUB_TOKEN_PLACEHOLDER', token)
              print("Token replacement completed")
              print("After replacement - placeholder still found:", "GITHUB_TOKEN_PLACEHOLDER" in config)
          else:
              print("ERROR: PRIVATE_REPO_TOKEN not found in environment")

          # Write back the config
          with open('src-tauri/tauri.conf.json', 'w') as f:
              f.write(config)
              
          # Validate JSON structure
          try:
              with open('src-tauri/tauri.conf.json', 'r') as f:
                  json_data = json.load(f)
              print("JSON validation: SUCCESS")
              print("Endpoints type:", type(json_data.get('plugins', {}).get('updater', {}).get('endpoints', 'Not found')))
          except Exception as e:
              print("JSON validation: FAILED -", str(e))
          EOF
          
          echo "Config before replacement:"
          grep -n "endpoints" src-tauri/tauri.conf.json || echo "endpoints not found"
          
          python3 replace_token.py
          
          echo "Config after replacement:"
          grep -n "endpoints" src-tauri/tauri.conf.json || echo "endpoints not found"
        env:
          PRIVATE_REPO_TOKEN: ${{ secrets.PRIVATE_REPO_TOKEN }}

      - name: build the app
        uses: tauri-apps/tauri-action@v0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
        with:
          tagName: ${{ github.ref_name }}
          releaseName: 'Risk Calculator v__VERSION__'
          releaseBody: 'See the assets to download this version.'
          releaseDraft: false
          prerelease: false
          args: ${{ matrix.args }}

      - name: Wait for release to be fully created
        shell: bash
        run: |
          echo "Waiting 30 seconds for release to be fully processed..."
          sleep 30

      - name: Debug build artifacts
        shell: bash
        run: |
          echo "=== Checking for signature files ==="
          find . -name "*.sig" -type f -exec ls -la {} \; || echo "No .sig files found"
          
          echo "=== All files in target/release/bundle ==="
          find ./src-tauri/target -type f -name "*" | head -20
          
          echo "=== Specifically looking for bundles and sigs ==="
          find ./src-tauri/target -name "*.dmg" -o -name "*.exe" -o -name "*.msi" -o -name "*.deb" -o -name "*.AppImage" -o -name "*.sig" 2>/dev/null || echo "No bundle files found"
          
          echo "=== Environment variables ==="
          echo "TAURI_SIGNING_PRIVATE_KEY set: $([ -n "$TAURI_SIGNING_PRIVATE_KEY" ] && echo "YES" || echo "NO")"
          echo "GITHUB_TOKEN set: $([ -n "$GITHUB_TOKEN" ] && echo "YES" || echo "NO")"

      - name: Upload missing signature files
        shell: bash
        run: |
          # Install jq based on platform
          if [[ "${{ matrix.platform }}" == "ubuntu-"* ]]; then
            sudo apt-get update && sudo apt-get install -y jq
          elif [[ "${{ matrix.platform }}" == "macos-"* ]]; then
            brew install jq
          elif [[ "${{ matrix.platform }}" == "windows-"* ]]; then
            # Use GitHub's pre-installed jq on Windows
            echo "Using pre-installed jq on Windows"
          fi
          
          echo "=== Checking what got uploaded to release ==="
          RELEASE_DATA=$(curl -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/releases/tags/${{ github.ref_name }}")
          
          echo "Release assets:"
          echo "$RELEASE_DATA" | jq -r '.assets[].name' || echo "Failed to parse release data"
          
          echo "=== Looking for signature files that might need manual upload ==="
          for sig_file in $(find ./src-tauri/target -name "*.sig" -type f 2>/dev/null); do
            echo "Found signature file: $sig_file"
            filename=$(basename "$sig_file")
            
            # Check if this signature file was already uploaded
            asset_exists=$(echo "$RELEASE_DATA" | jq -r --arg name "$filename" '.assets[] | select(.name == $name) | .name' 2>/dev/null)
            
            if [ -z "$asset_exists" ]; then
              echo "Signature file $filename was not uploaded, uploading manually..."
              
              # Get upload URL
              upload_url=$(echo "$RELEASE_DATA" | jq -r '.upload_url' | sed 's/{?name,label}//')
              
              # Upload the signature file
              response=$(curl -X POST \
                -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                -H "Content-Type: application/octet-stream" \
                --data-binary @"$sig_file" \
                "${upload_url}?name=${filename}" \
                -w "HTTP_CODE:%{http_code}")
              
              echo "Upload response: $response"
              echo "Uploaded $filename"
            else
              echo "Signature file $filename already exists in release"
            fi
          done

  generate-updater-json:
    needs: publish-tauri
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v4

      - name: Get release data
        id: release
        run: |
          RELEASE_DATA=$(curl -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/releases/tags/${{ github.ref_name }}")
          echo "release_data<<EOF" >> $GITHUB_OUTPUT
          echo "$RELEASE_DATA" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Generate latest.json
        shell: bash
        run: |
          # Generate current timestamp
          CURRENT_DATE=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          
          cat > latest.json << EOF
          {
            "version": "${{ github.ref_name }}",
            "notes": "Latest release of Risk Calculator",
            "pub_date": "${CURRENT_DATE}",
            "platforms": {}
          }
          EOF

          cat > parse_release.py << 'EOF'
          import json
          import os
          import re

          # Write release data to file
          release_json = '''${{ steps.release.outputs.release_data }}'''
          with open('release_data.json', 'w') as f:
              f.write(release_json)

          # Parse release data
          with open('release_data.json', 'r') as f:
              release = json.load(f)

          with open('latest.json', 'r') as f:
              update_data = json.load(f)

          platforms = {}
          
          print(f"Processing {len(release['assets'])} assets...")

          for asset in release['assets']:
              name = asset['name']
              download_url = asset['browser_download_url']
              
              print(f"Processing asset: {name}")
              
              # Skip signature files
              if name.endswith('.sig'):
                  continue
              
              # Determine platform from filename
              platform_key = None
              if any(x in name.lower() for x in ['x64-setup.exe', 'x64_en-us.msi', '_x64_en-us.msi']):
                  platform_key = 'windows-x86_64'
              elif 'aarch64.dmg' in name.lower():
                  platform_key = 'darwin-aarch64'
              elif any(x in name.lower() for x in ['x64.dmg', '_x64.dmg']):
                  platform_key = 'darwin-x86_64'
              elif any(x in name.lower() for x in ['amd64.appimage', 'amd64.deb', '_amd64.appimage']):
                  platform_key = 'linux-x86_64'
              
              if platform_key:
                  print(f"Mapped {name} to platform: {platform_key}")
                  
                  # Check if signature file exists
                  sig_name = name + '.sig'
                  sig_asset = next((a for a in release['assets'] if a['name'] == sig_name), None)
                  
                  if sig_asset:
                      print(f"Found signature for: {name}")
                      platforms[platform_key] = {
                          "signature": "SIGNATURE_PLACEHOLDER",
                          "url": download_url
                      }
                  else:
                      print(f"WARNING: No signature found for: {name}")
                      # For now, we'll still add it but this should be investigated
                      platforms[platform_key] = {
                          "url": download_url
                      }
              else:
                  print(f"Could not determine platform for: {name}")

          print(f"Final platforms: {list(platforms.keys())}")
          update_data['platforms'] = platforms

          with open('latest.json', 'w') as f:
              json.dump(update_data, f, indent=2)
          
          print("Generated latest.json successfully")
          EOF
          
          python3 parse_release.py

      - name: Download signatures and update latest.json (if signatures exist)
        shell: bash
        run: |
          cat > download_signatures.py << 'EOF'
          import json
          import requests

          with open('latest.json', 'r') as f:
              update_data = json.load(f)

          release_data = '''${{ steps.release.outputs.release_data }}'''
          release = json.loads(release_data)

          for platform, info in update_data['platforms'].items():
              # Only try to download signature if the platform entry has a signature placeholder
              if 'signature' in info and info['signature'] == 'SIGNATURE_PLACEHOLDER':
                  url = info['url']
                  filename = url.split('/')[-1]
                  sig_filename = filename + '.sig'
                  
                  sig_asset = next((a for a in release['assets'] if a['name'] == sig_filename), None)
                  if sig_asset:
                      try:
                          headers = {'Authorization': 'token ${{ secrets.GITHUB_TOKEN }}'}
                          response = requests.get(sig_asset['browser_download_url'], headers=headers)
                          if response.status_code == 200:
                              signature = response.text.strip()
                              update_data['platforms'][platform]['signature'] = signature
                              print(f"Downloaded signature for {platform}")
                          else:
                              print(f"Failed to download signature for {platform}: {response.status_code}")
                              # Remove signature field if download failed
                              del update_data['platforms'][platform]['signature']
                      except Exception as e:
                          print(f"Error downloading signature for {platform}: {e}")
                          # Remove signature field if download failed
                          del update_data['platforms'][platform]['signature']
                  else:
                      print(f"Signature asset not found for {platform}")
                      # Remove signature field if asset not found
                      del update_data['platforms'][platform]['signature']

          with open('latest.json', 'w') as f:
              json.dump(update_data, f, indent=2)
          
          print("Updated signatures in latest.json")
          EOF
          
          python3 download_signatures.py

      - name: Commit latest.json to releases branch
        shell: bash
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          
          git checkout -B releases
          
          # Check if latest.json exists and add it
          if [ -f "latest.json" ]; then
            git add latest.json
            git commit -m "Update latest.json for ${{ github.ref_name }}" || exit 0
            git push origin releases --force
          else
            echo "latest.json not found"
            exit 1
          fi

