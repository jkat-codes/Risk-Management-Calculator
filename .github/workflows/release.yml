name: 'publish'

on:
  push:
    tags:
      - 'v*'

permissions:
  contents: write

jobs:
  publish-tauri:
    permissions:
      contents: write
    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: 'macos-latest'
            args: '--target aarch64-apple-darwin'
          - platform: 'macos-latest'  
            args: '--target x86_64-apple-darwin'
          - platform: 'windows-latest'
            args: ''

    runs-on: ${{ matrix.platform }}
    steps:
      - uses: actions/checkout@v4

      - name: setup node
        uses: actions/setup-node@v4
        with:
          node-version: lts/*
          cache: 'npm'

      - name: install Rust stable
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.platform == 'macos-latest' && 'aarch64-apple-darwin,x86_64-apple-darwin' || '' }}

      - name: Rust cache
        uses: swatinem/rust-cache@v2
        with:
          workspaces: './src-tauri -> target'

      - name: install Tauri CLI
        run: cargo install tauri-cli

      - name: install dependencies (ubuntu only)
        if: matrix.platform == 'ubuntu-22.04'
        run: |
          sudo apt-get update
          sudo apt-get install -y libwebkit2gtk-4.1-dev libgtk-3-dev libayatana-appindicator3-dev librsvg2-dev

      - name: install frontend dependencies
        run: npm install

      - name: Update tauri config with token
        shell: bash
        run: |
          cat > replace_token.py << 'EOF'
          import json
          import os

          # Read the config file
          with open('src-tauri/tauri.conf.json', 'r') as f:
              config = f.read()

          print("Before replacement:")
          print("GITHUB_TOKEN_PLACEHOLDER found:", "GITHUB_TOKEN_PLACEHOLDER" in config)
          
          # Replace the placeholder with the actual token
          token = os.environ.get('PRIVATE_REPO_TOKEN', '')
          if token:
              config = config.replace('GITHUB_TOKEN_PLACEHOLDER', token)
              print("Token replacement completed")
              print("After replacement - placeholder still found:", "GITHUB_TOKEN_PLACEHOLDER" in config)
          else:
              print("ERROR: PRIVATE_REPO_TOKEN not found in environment")

          # Write back the config
          with open('src-tauri/tauri.conf.json', 'w') as f:
              f.write(config)
              
          # Validate JSON structure
          try:
              with open('src-tauri/tauri.conf.json', 'r') as f:
                  json_data = json.load(f)
              print("JSON validation: SUCCESS")
              print("Endpoints type:", type(json_data.get('plugins', {}).get('updater', {}).get('endpoints', 'Not found')))
          except Exception as e:
              print("JSON validation: FAILED -", str(e))
          EOF
          
          echo "Config before replacement:"
          grep -n "endpoints" src-tauri/tauri.conf.json || echo "endpoints not found"
          
          python3 replace_token.py
          
          echo "Config after replacement:"
          grep -n "endpoints" src-tauri/tauri.conf.json || echo "endpoints not found"
        env:
          PRIVATE_REPO_TOKEN: ${{ secrets.PRIVATE_REPO_TOKEN }}

      - uses: tauri-apps/tauri-action@v0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
        with:
          tagName: ${{ github.ref_name }}
          releaseName: 'Risk Calculator v__VERSION__'
          releaseBody: 'See the assets to download this version.'
          releaseDraft: false
          prerelease: false
          args: ${{ matrix.args }}

  generate-updater-json:
    needs: publish-tauri
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v4

      - name: Get release data
        id: release
        run: |
          RELEASE_DATA=$(curl -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/releases/tags/${{ github.ref_name }}")
          echo "release_data<<EOF" >> $GITHUB_OUTPUT
          echo "$RELEASE_DATA" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Generate latest.json
        shell: bash
        run: |
          # Generate current timestamp
          CURRENT_DATE=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          
          cat > latest.json << EOF
          {
            "version": "${{ github.ref_name }}",
            "notes": "Latest release of Risk Calculator",
            "pub_date": "${CURRENT_DATE}",
            "platforms": {}
          }
          EOF

          cat > parse_release.py << 'EOF'
          import json
          import os
          import re

          # Write release data to file
          release_json = '''${{ steps.release.outputs.release_data }}'''
          with open('release_data.json', 'w') as f:
              f.write(release_json)

          # Parse release data
          with open('release_data.json', 'r') as f:
              release = json.load(f)

          with open('latest.json', 'r') as f:
              update_data = json.load(f)

          platforms = {}
          
          print(f"Processing {len(release['assets'])} assets...")

          for asset in release['assets']:
              name = asset['name']
              download_url = asset['browser_download_url']
              
              print(f"Processing asset: {name}")
              
              # Skip signature files for now
              if name.endswith('.sig'):
                  continue
              
              # Find corresponding signature file
              sig_name = name + '.sig'
              sig_asset = next((a for a in release['assets'] if a['name'] == sig_name), None)
              
              if sig_asset:
                  print(f"Found signature for: {name}")
                  
                  # Determine platform from filename
                  platform_key = None
                  if any(x in name.lower() for x in ['x64-setup.exe', 'x64_en-us.msi', '_x64_en-us.msi']):
                      platform_key = 'windows-x86_64'
                  elif 'aarch64.dmg' in name.lower():
                      platform_key = 'darwin-aarch64'
                  elif any(x in name.lower() for x in ['x64.dmg', '_x64.dmg']):
                      platform_key = 'darwin-x86_64'
                  elif any(x in name.lower() for x in ['amd64.appimage', 'amd64.deb', '_amd64.appimage']):
                      platform_key = 'linux-x86_64'
                  
                  if platform_key:
                      print(f"Mapped {name} to platform: {platform_key}")
                      platforms[platform_key] = {
                          "signature": "SIGNATURE_PLACEHOLDER",
                          "url": download_url
                      }
                  else:
                      print(f"Could not determine platform for: {name}")
              else:
                  print(f"No signature found for: {name}")

          print(f"Final platforms: {list(platforms.keys())}")
          update_data['platforms'] = platforms

          with open('latest.json', 'w') as f:
              json.dump(update_data, f, indent=2)
          
          print("Generated latest.json successfully")
          EOF
          
          python3 parse_release.py

      - name: Download signatures and update latest.json
        shell: bash
        run: |
          cat > download_signatures.py << 'EOF'
          import json
          import requests
          import base64

          with open('latest.json', 'r') as f:
              update_data = json.load(f)

          release_data = '''${{ steps.release.outputs.release_data }}'''
          release = json.loads(release_data)

          for platform, info in update_data['platforms'].items():
              url = info['url']
              filename = url.split('/')[-1]
              sig_filename = filename + '.sig'
              
              sig_asset = next((a for a in release['assets'] if a['name'] == sig_filename), None)
              if sig_asset:
                  headers = {'Authorization': 'token ${{ secrets.GITHUB_TOKEN }}'}
                  response = requests.get(sig_asset['browser_download_url'], headers=headers)
                  if response.status_code == 200:
                      signature = response.text.strip()
                      update_data['platforms'][platform]['signature'] = signature

          with open('latest.json', 'w') as f:
              json.dump(update_data, f, indent=2)
          EOF
          
          python3 download_signatures.py

      - name: Upload latest.json to release
        shell: bash
        run: |
          # Upload latest.json as a release asset
          gh release upload ${{ github.ref_name }} latest.json --clobber
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

